=== docs/specs/ping_command_spec.md ===
# Ping Command Specification (v3)

## 1. Executive Summary
This feature introduces a simple `/ping` command to the Telegram bot (v3 architecture). The command serves as a connectivity test, responding with "pong" to verify the bot is active and responsive.

**Goals:**
- Provide a quick, low-overhead connectivity check.
- Maintain existing security protocols (chat ID authorization).

## 2. Technical Design

### Components
- **Bot Command Handler**: A new regex-based command handler in `scripts/bot/commands/general.js`.
- **Authorization**: Must leverage the existing `authorized(msg)` check provided by `bot_v3.js`.

### Data Flow
1. User sends `/ping`.
2. Bot validates `authorized(msg)`.
3. If authorized, bot replies "pong".
4. If unauthorized, bot ignores (security by silence).

## 3. Implementation Plan

### Phase 1: Implementation
- **File**: `scripts/bot/commands/general.js`
- **Action**: Add `registerCommand(/^\/ping/, ...)` inside the `register` function.
- **Logic**: Simple reply "pong".

### Phase 2: Testing
- **File**: `scripts/bot/bot_test_v3.js`
- **Action**:
    1.  Add `/ping` to the `expectedCommands` list in the "Command Handler Coverage" contract test.
    2.  Add a new behavioral test case: `test('[behavioral] /ping replies pong', ...)` simulating a user message.
- **Verification**: `node scripts/bot/bot_test_v3.js`

## 4. Security & Risks
- **Risk**: Unauthorized users spamming ping.
- **Mitigation**: The standard `authorized(msg)` check will be applied. Unauthorized messages trigger no response.

## 5. Testing Strategy
| Component | Test Case | Expected Outcome |
|-----------|-----------|------------------|
| Bot (v3) | `/ping` from authorized user | Reply: "pong" |
| Bot (v3) | `/ping` from unauthorized user | No reply |


=== docs/specs/bot_test_refactoring_spec.md ===
# Bot.test.js Critical Review ‚Äî Security, Maintainability & Refactoring Spec

> **Scope**: `scripts/bot/bot.test.js` (2,386 lines, 102 KB, 151 tests)
> **Date**: 2026-02-20
> **Status**: Analysis only ‚Äî no implementation

---

## 1. Architectural Issues

### üî¥ ARCH-1: Custom Test Framework ‚Äî No Standard Runner
**Lines**: 33‚Äì86

The file implements its own test framework (`test()`, `setup()`, `teardown()`, `skip()`). This means:
- No parallel execution, no `--watch` mode, no `--grep` filtering
- No `beforeAll`/`afterAll` ‚Äî each test does full `setup()`/`teardown()` (rm + mkdir)
- No `describe` blocks ‚Äî test organization relies on `console.log` section headers
- No timeout controls ‚Äî hanging tests block the entire suite
- No test isolation verification ‚Äî shared mutable state (`mockBot`, `CHAT_ID`)

**Impact**: 151 tests run sequentially with full filesystem teardown between each = slow; no way to run a subset.

**Recommendation**: Migrate to Node.js built-in `node:test` runner (available since Node 18) for zero-dependency testing with `describe`/`it`/`beforeEach`, parallel execution, and `--test-name-pattern` filtering.

---

### üî¥ ARCH-2: Tests Never Import bot.js
**Lines**: 88‚Äì137 (helpers), 714‚Äì777 (registries)

The test file **copy-pastes** helpers and constants from bot.js instead of importing them:

| Duplicated Code | Lines in test | Lines in bot.js | Drift Risk |
|---|---|---|---|
| `readJsonSafe()` | 90‚Äì96 | 81‚Äì87 | ‚úÖ In sync |
| `atomicWrite()` | 98‚Äì103 | 89‚Äì97 | ‚ùå **Diverged** |
| `writeToInbox()` | 105‚Äì115 | 99‚Äì111 | ‚ö†Ô∏è Minor diff |
| `getState()` / `updateState()` | 129‚Äì137 | 124‚Äì133 | ‚ö†Ô∏è Missing defaults |
| `PLATFORM_MODELS` | 737‚Äì750 | 237‚Äì250 | ‚úÖ In sync |
| `TIER_EMOJI` | 752 | 263 | ‚úÖ In sync |
| `DIFFICULTY_LABEL()` | 754‚Äì761 | 280‚Äì287 | ‚úÖ In sync |
| `formatExecutionPlan()` | 763‚Äì777 | 300‚Äì314 | ‚úÖ In sync |
| `loadExecutionPlan()` / `saveExecutionPlan()` | 715‚Äì722 | 291‚Äì298 | ‚úÖ In sync |
| `writeDispatch()` | 724‚Äì735 | 340‚Äì354 | ‚úÖ In sync |

**Critical divergence ‚Äî `atomicWrite()`:**
```diff
// bot.js (correct ‚Äî atomic rename)
- const tmp = `${filePath}.tmp`;
- writeFileSync(tmp, JSON.stringify(data, null, 2));
- renameSync(tmp, filePath);

// bot.test.js (wrong ‚Äî double write, no rename)
+ const tmp = filePath + '.tmp';
+ writeFileSync(tmp, JSON.stringify(data, null, 2));
+ writeFileSync(filePath, JSON.stringify(data, null, 2));
+ try { unlinkSync(tmp); } catch { /* ignore */ }
```

The test version writes the file **twice** and never uses `renameSync`. This means the tests validate a different code path than production.

**Recommendation**: Export shared logic from bot.js into importable modules. Tests import the actual code, not copies.

---

### üü° ARCH-3: ~60% of Tests Are Static Source Grep, Not Behavioral Tests
**Lines**: 644‚Äì708, 1746‚Äì2067, 2192‚Äì2367

A large portion of tests read source files and check for string patterns:
```javascript
await test('regression: watcher has run_agent() function', () => {
    const watcher = readFileSync(resolve(PROJECT_ROOT, 'scripts', 'watcher.sh'), 'utf8');
    ok(watcher.includes('run_agent()'), 'watcher should define run_agent function');
});
```

**Count**: ~90 out of 151 tests read `.js` or `.sh` files and `ok(src.includes(...))`. These are **contract smoke tests** ‚Äî they verify that certain strings exist in source files. While useful as regression guards, they:
- Don't test behavior
- Break on any rename/refactor (fragile)
- Can't catch logic bugs
- Give false confidence

**Recommendation**: Keep a small set (~20) of critical contract tests. Replace the rest with behavioral tests that exercise actual functions.

---

## 2. Maintainability Issues

### üî¥ MAINT-1: Stale BOT_COMMANDS in Test vs Production
**Line 451** (test) vs **Line 899** (bot.js)

| Test BOT_COMMANDS (8) | Production BOT_COMMANDS (18) |
|---|---|
| ‚úÖ /stop | ‚úÖ /stop |
| ‚úÖ /status | ‚úÖ /status |
| ‚úÖ /project | ‚úÖ /project |
| ‚úÖ /list | ‚úÖ /list |
| ‚úÖ /model | ‚úÖ /model |
| ‚úÖ /add | ‚úÖ /add |
| ‚úÖ /help | ‚úÖ /help |
| ‚úÖ /sprint | ‚úÖ /sprint |
| ‚ùå missing | /backend |
| ‚ùå missing | /version |
| ‚ùå missing | /review_plan |
| ‚ùå missing | /clear_lock |
| ‚ùå missing | /restart |
| ‚ùå missing | /watchdog |
| ‚ùå missing | /diagnose |
| ‚ùå missing | /autofix |
| ‚ùå missing | /apply_fix |
| ‚ùå missing | /discard_fix |
| ‚ùå missing | /kill |

The test validates completeness against a **stale 8-command list** instead of the actual 18-command list. This means the test passes but the guard is broken ‚Äî 10 commands are missing from the test's reference.

**Fix**: Import `BOT_COMMANDS` from bot.js, or auto-scan `bot.onText` handlers to build the reference list.

---

### üü° MAINT-2: Mock Flow Tests Re-implement Watcher Logic
**Lines**: 989‚Äì1694 (700+ lines)

The "Plan-Review-Execute Flow (Mock)" section manually re-implements watcher.sh behavior in JavaScript:
```javascript
// Simulate: watcher plan mode enforcement ‚Äî revert code files
const isPlanMode = existsSync(MOCK_PLAN_MODE);
if (isPlanMode) {
    const codeExtensions = ['.js', '.py', '.sh', ...];
    for (const f of modifiedFiles) {
        const ext = f.substring(f.lastIndexOf('.'));
        if (codeExtensions.includes(ext)) {
            unlinkSync(f);
        }
    }
}
```

This doesn't test `watcher.sh` ‚Äî it tests a JavaScript reimplementation of watcher.sh logic. If watcher.sh changes its behavior, these tests still pass.

**Recommendation**: Either:
1. Extract watcher logic into testable functions (bash ‚Üí sourced library)
2. Or use actual shell-based integration tests that invoke watcher.sh in a sandbox

---

### üü° MAINT-3: Python Auto-Load Tests Shell Out Dangerously
**Lines**: 2097‚Äì2185

```javascript
const result = execSync(`python3 -c '${pyScript.replace(/'/g, "'\\''")}' '${mockTasks}' '${mockState}' '${specRef}'`, {
    encoding: 'utf8', timeout: 5000
}).trim();
```

The tests extract a Python script from `watcher.sh` via string slicing, then execute it via `execSync`. This is:
- Fragile (depends on exact string markers like `import json, re, sys`)
- A potential injection vector if the extracted script changes
- Hard to debug when it fails

**Recommendation**: Extract the Python auto-load logic into a standalone `scripts/autoload_plan.py` file that both watcher.sh and the tests can invoke directly.

---

### üü¢ MAINT-4: Good Test Coverage for Core Features
Despite the issues above, the test suite covers critical areas well:
- JSON I/O safety (partial writes, concurrent access, malformed files)
- Auth check (string vs number chat IDs)
- Execution plan lifecycle (create ‚Üí assign ‚Üí approve ‚Üí dispatch ‚Üí stop ‚Üí re-plan)
- Edge cases (empty markers, corrupted state, race conditions, renamed files)
- Self-healing pipeline (restart, watchdog, diagnose, autofix)

---

## 3. Refactoring Opportunities

### REF-1: Extract Shared Code Into Importable Modules
If bot.js is modularized per the bot_refactoring_spec, tests can directly import:
```javascript
import { readJsonSafe, atomicWrite, getState } from '../lib/state.js';
import { PLATFORM_MODELS, TIER_DEFAULTS } from '../lib/registries.js';
```

This eliminates all 200+ lines of duplicated helper code.

---

### REF-2: Categorize Tests Into 3 Tiers
| Tier | Count (est.) | Purpose | Speed |
|---|---|---|---|
| Unit | ~40 | Test pure functions (formatPlan, difficultyLabel, auth check) | <1s |
| Contract | ~20 | Verify source file invariants (command exists, variable defined) | <2s |
| Integration | ~30 | Test actual flows with sandbox (inbox/outbox, state, dispatch) | <5s |

Current: everything is in one file, runs sequentially. Split into `test/unit.test.js`, `test/contract.test.js`, `test/integration.test.js`.

---

### REF-3: Replace `readFileSync` Source Scanning With Proper Mocking
Instead of:
```javascript
const src = readFileSync('bot.js', 'utf8');
ok(src.includes('bot.onText(/^\\/kill/'));
```

Import the actual handler and test it:
```javascript
import { killHandler } from '../commands/admin.js';
test('kill clears lock file', async () => {
    writeFileSync(LOCK, '12345');
    await killHandler(mockMsg);
    ok(!existsSync(LOCK));
});
```

---

### REF-4: Use `node:test` Built-in Runner
```javascript
import { describe, it, before, after } from 'node:test';
import assert from 'node:assert';

describe('JSON I/O', () => {
    before(() => setup());
    after(() => teardown());
    
    it('returns fallback for missing file', () => {
        const result = readJsonSafe('/nonexistent', { ok: true });
        assert.deepStrictEqual(result, { ok: true });
    });
});
```

Benefits: `--test-name-pattern`, parallel execution, TAP output, `--watch` mode.

---

## 4. Priority Matrix

| ID | Category | Severity | Effort | Priority |
|---|---|---|---|---|
| MAINT-1 | Bug | HIGH | Trivial | **P0** ‚Äî stale BOT_COMMANDS (false pass) |
| ARCH-2 | Maintainability | HIGH | Low | **P1** ‚Äî atomicWrite divergence |
| ARCH-3 | Quality | MEDIUM | Medium | **P2** ‚Äî convert grep tests to behavioral |
| MAINT-2 | Quality | MEDIUM | Medium | **P2** ‚Äî mock flow tests don't test real code |
| MAINT-3 | Security | LOW | Low | **P2** ‚Äî Python shell-out extraction |
| REF-1 | Refactoring | HIGH | Medium | **P3** ‚Äî import from modular bot.js |
| ARCH-1 | Refactoring | MEDIUM | Medium | **P3** ‚Äî migrate to node:test |
| REF-2 | Refactoring | LOW | Medium | **P3** ‚Äî tiered test files |

---

## 5. Relationship to bot.js Refactoring

The test refactoring is **blocked by** the bot.js modular split (P3 in `bot_refactoring_spec.md`). Recommended order:

```mermaid
graph LR
    A["P0: Fix stale BOT_COMMANDS"] --> B["P1: Fix atomicWrite divergence"]
    B --> C["bot.js modular split"]
    C --> D["Import shared code in tests"]
    D --> E["Migrate to node:test"]
    E --> F["Split into tiered test files"]
```

> [!IMPORTANT]
> The P0 fix (stale BOT_COMMANDS) and P1 fix (atomicWrite divergence) can be done **now** without waiting for the modular refactor. Everything P2+ should wait.


=== docs/specs/bot_refactoring_spec.md ===
# Bot.js Critical Review ‚Äî Security, Maintainability & Refactoring Spec

> **Scope**: `scripts/bot/bot.js` (1,373 lines, 54 KB)
> **Date**: 2026-02-20
> **Status**: Analysis only ‚Äî no implementation

---

## 1. Security Issues

### üî¥ SEC-1: Shell Injection in `/apply_fix` and `/discard_fix`
**Lines**: 1097, 1118
**Severity**: HIGH

The hotfix branch name is extracted from `git branch` output via regex, then interpolated directly into a shell command:
```javascript
execSync(`git checkout main && git merge ${hotfix} --no-edit`, { cwd: PROJECT_DIR });
```

If a branch named `hotfix/auto-123; rm -rf /` existed, the shell would execute the injected command. While the regex (`/hotfix\/auto-\d+/`) currently limits this to digits, the pattern is unsafe by design.

**Fix (two layers)**:

**Layer 1 ‚Äî Validate before interpolation (P1, 3-line fix):**
```javascript
const hotfix = match[0].trim();
if (!/^hotfix\/auto-\d+$/.test(hotfix)) {
    await bot.sendMessage(CHAT_ID, '‚ùå Invalid branch name.');
    return;
}
```
This strict regex rejects anything that isn't exactly `hotfix/auto-<digits>`. Preserves full auto-fix functionality since the watchdog creates branches matching this exact pattern.

**Layer 2 ‚Äî Eliminate shell interpolation entirely (P3, modular refactor):**
```javascript
// Instead of:
execSync(`git checkout main && git merge ${hotfix} --no-edit`);

// Use execFileSync (no shell at all):
import { execFileSync } from 'child_process';
execFileSync('git', ['checkout', 'main'], { cwd: PROJECT_DIR });
execFileSync('git', ['merge', hotfix, '--no-edit'], { cwd: PROJECT_DIR });
```
`execFileSync` passes arguments as an array directly to the process ‚Äî shell metacharacters like `; rm -rf /` are treated as literal git arguments, not commands. Apply to all handlers: `/apply_fix`, `/discard_fix`, `/restart`, `/kill`.

---

### üî¥ SEC-2: Overly Broad `pkill` in `/kill`
**Lines**: 1130‚Äì1131

```javascript
execSync('pkill -f "kilo" 2>/dev/null || true');
execSync('pkill -f "gemini" 2>/dev/null || true');
```

`pkill -f "gemini"` matches *any* process containing "gemini" ‚Äî including unrelated tools (e.g., the `gemini settings` command currently running, or other user processes). This can kill processes outside the bot's scope.

**Fix**: Use more specific patterns like `pkill -f "gemini -p"` or `pkill -f "node.*kilo"`, or better: track the spawned PID and kill by PID, not pattern.

---

### üü° SEC-3: No Input Sanitization on `/add` Path
**Lines**: 865‚Äì883

```javascript
bot.onText(/^\/add\s+(\S+)\s+(.+)/, async (msg, match) => {
    let path = match[2].trim();
    if (!isAbsolute(path)) {
        path = resolve(DEFAULT_PROJECT_DIR, path);
    }
```

The path is resolved and checked with `existsSync`, but there's no protection against path traversal (e.g., `/add test ../../../etc`). While `existsSync` prevents registering non-existent dirs, it doesn't validate that the path is within a safe boundary.

**Fix**: Validate the resolved path starts with an allowed prefix (e.g., the user's home directory or project root).

---

### üü° SEC-4: Duplicate `/kill` Handler
**Lines**: 776‚Äì791 AND 1126‚Äì1138

The `/kill` command handler is defined **twice** ‚Äî identical code at two locations. Both will execute on a `/kill` message (node-telegram-bot-api fires all matching handlers). This means every `/kill` runs the pkill commands twice.

**Fix**: Remove the duplicate at lines 776‚Äì791.

---

### üü¢ SEC-5: CHAT_ID Auth is Consistent
Every command handler checks `String(msg.chat.id) !== String(CHAT_ID)`. The callback_query handler also checks at line 439. This is good ‚Äî no auth gaps found.

---

## 2. Maintainability Issues

### üî¥ MAINT-1: Monolithic 1,373-Line File
The file contains **everything**: config, helpers, 25+ command handlers, model registries, execution plan logic, health checks, outbox relay, and error handling. This makes it:
- Hard to navigate (25+ `bot.onText` handlers scattered through 1,373 lines)
- Risky to edit (Gemini CLI deleted 70 lines because it couldn't reason about the full file)
- Impossible to unit test individual handlers

**Recommendation**: Extract into modules:

| Module | Lines | Contents |
|---|---|---|
| `config.js` | ~55 | Paths, constants, env loading |
| `state.js` | ~50 | `getState`, `updateState`, `readJsonSafe`, `atomicWrite` |
| `registries.js` | ~80 | Model/backend/tier registries |
| `commands/workflow.js` | ~80 | `/startup`, `/shutdown`, `/sprint`, `/stop`, `/new` |
| `commands/admin.js` | ~120 | `/status`, `/restart`, `/kill`, `/clear_lock`, `/watchdog` |
| `commands/model.js` | ~40 | `/model`, `/backend` |
| `commands/project.js` | ~60 | `/project`, `/add`, `/list` |
| `commands/healing.js` | ~80 | `/diagnose`, `/autofix`, `/apply_fix`, `/discard_fix` |
| `commands/plan.js` | ~350 | `/review_plan` + all `ep_*` callback handlers |
| `health.js` | ~80 | Health check interval, watcher monitoring |
| `relay.js` | ~100 | Outbox polling, `sendAsFile`, message relay |
| `bot.js` (main) | ~80 | Imports, bot init, startup notification, error handlers |

---

### üü° MAINT-2: Duplicate Import
**Lines**: 22 AND 38

```javascript
import 'dotenv/config';          // Line 22
import dotenv from 'dotenv';     // Line 38
dotenv.config({ path: ... });
```

`dotenv` is imported and configured twice. Line 22 loads from `process.cwd()/.env` and line 38 loads from `SCRIPT_DIR/.env`. The first load is unnecessary and may load the wrong `.env` if `cwd` differs from script dir.

**Fix**: Remove line 22. Keep only the explicit path-based import at line 38.

---

### üü° MAINT-3: Inconsistent State Access
Three different patterns are used to read `state.json`:

| Pattern | Used at | Risk |
|---|---|---|
| `getState()` | Lines 124, 207, 318, 445, 651, 800, 830, 860, 887 | ‚úÖ Correct |
| `readJsonSafe(STATE_FILE, {})` | Lines 358, 380 | ‚ö†Ô∏è Missing defaults |
| `JSON.parse(readFileSync(STATE_FILE, 'utf8'))` | Line 1073 | ‚ùå Can throw |

The `/autofix` handler (line 1073) reads state with raw `JSON.parse` ‚Äî no fallback, no error handling for missing file. The `/model` and `/backend` handlers use `readJsonSafe` with `{}` as fallback ‚Äî missing `activeProject` and `projects` defaults.

**Fix**: Use `getState()` everywhere. It already provides safe defaults.

---

### üü° MAINT-4: `PROJECT_DIR` Undefined
**Lines**: 1090, 1097, 1098, 1111, 1118

The `/apply_fix` and `/discard_fix` handlers use `PROJECT_DIR` in `execSync({ cwd: PROJECT_DIR })`, but `PROJECT_DIR` is never defined. `PROJECT_ROOT` and `DEFAULT_PROJECT_DIR` exist, but not `PROJECT_DIR`. This means these commands will silently use `undefined` as cwd, falling back to `process.cwd()`.

**Fix**: Replace `PROJECT_DIR` with `DEFAULT_PROJECT_DIR` or `getState().activeProject`.

---

### üü¢ MAINT-5: Atomic Writes Are Well-Implemented
`atomicWrite()` at line 89 uses tmp+rename pattern. The outbox relay at line 1339 re-reads before writing to avoid race conditions with the watcher. This is correct.

---

## 3. Refactoring Opportunities

### REF-1: Config-Driven Model Registry
**Lines**: 229‚Äì277

Model IDs, labels, tier defaults, and platform mappings are hardcoded across 5 separate objects (`MODEL_OPTIONS`, `PLATFORM_MODELS`, `PLATFORM_LABELS`, `BACKEND_OPTIONS`, `TIER_DEFAULTS`). Adding a new model requires touching 3‚Äì5 places.

**Recommendation**: Single `models.json` config file:
```json
{
  "platforms": {
    "gemini": {
      "label": "üíª Gemini CLI",
      "models": [
        { "id": "gemini-2.5-flash", "label": "‚ö° Flash 2.5", "tier": "mid" }
      ]
    }
  }
}
```

---

### REF-2: Centralize Auth Guard
Every handler repeats: `if (String(msg.chat.id) !== String(CHAT_ID)) return;`

**Recommendation**: Middleware-style wrapper:
```javascript
function authorized(handler) {
    return async (msg, ...args) => {
        if (String(msg.chat.id) !== String(CHAT_ID)) return;
        return handler(msg, ...args);
    };
}
bot.onText(/^\/help/, authorized(async (msg) => { ... }));
```

---

### REF-3: Extract Callback Query Router
**Lines**: 437‚Äì760 (323 lines!)

The single `bot.on('callback_query')` handler is a 323-line if/else chain with 12 branches. Each branch is a separate feature (model selection, backend selection, project switching, 8 execution plan states).

**Recommendation**: Route-based dispatch:
```javascript
const callbackHandlers = {
    'model:': handleModelCallback,
    'backend:': handleBackendCallback,
    'project:': handleProjectCallback,
    'ep_platform:': handleEpPlatform,
    // ...
};
```

---

### REF-4: Hardcoded Telegram Strings
All user-facing strings are inline. Changes to UX copy require editing handler code.

**Recommendation**: Extract to a `messages.js` constants file or i18n layer.

---

### REF-5: `BOT_COMMANDS` Array Is Fragile
**Line**: 899

```javascript
const BOT_COMMANDS = ['/stop', '/status', '/project', '/list', ... '/kill'];
```

This array must be manually kept in sync with actual handlers. Adding a command but forgetting to add it here means the message handler will forward it to the inbox ‚Äî causing the watcher to run it as a Gemini prompt.

**Recommendation**: Auto-generate from registered handlers, or use a central command registry that both the handler and the filter reference.

---

## 4. Priority Matrix

| ID | Category | Severity | Effort | Priority |
|---|---|---|---|---|
| SEC-4 | Security | HIGH | Trivial | **P0** ‚Äî remove duplicate `/kill` |
| SEC-2 | Security | HIGH | Low | **P0** ‚Äî fix overly broad `pkill` |
| MAINT-4 | Bug | HIGH | Trivial | **P0** ‚Äî `PROJECT_DIR` undefined |
| MAINT-2 | Maintainability | LOW | Trivial | **P1** ‚Äî remove duplicate import |
| SEC-1 | Security | MEDIUM | Low | **P1** ‚Äî sanitize branch names |
| MAINT-3 | Maintainability | MEDIUM | Low | **P1** ‚Äî use `getState()` everywhere |
| REF-2 | Refactoring | LOW | Low | **P2** ‚Äî centralize auth |
| REF-5 | Refactoring | MEDIUM | Low | **P2** ‚Äî command registry |
| REF-1 | Refactoring | LOW | Medium | **P3** ‚Äî config-driven models |
| MAINT-1 | Refactoring | HIGH | High | **P3** ‚Äî modular architecture |
| REF-3 | Refactoring | LOW | Medium | **P3** ‚Äî callback router |
| REF-4 | Refactoring | LOW | Medium | **P4** ‚Äî string extraction |
| SEC-3 | Security | LOW | Low | **P4** ‚Äî path traversal guard |

---

## 5. Recommended Execution Order

1. **Quick wins (P0)**: Fix duplicate `/kill`, broad `pkill`, undefined `PROJECT_DIR` ‚Äî 3 trivial fixes, immediate security + stability improvement
2. **Consistency pass (P1)**: Duplicate import, branch sanitization, consistent state access ‚Äî no architecture change needed
3. **Structure prep (P2)**: Auth wrapper + command registry ‚Äî sets foundation for modular split
4. **Modular refactor (P3)**: Extract into ~12 modules ‚Äî biggest effort, biggest reward. Should be done on a feature branch with full test coverage before and after.
5. **Polish (P4)**: String extraction, path guards ‚Äî nice-to-have

> [!IMPORTANT]
> The modular refactor (MAINT-1 / P3) is the most impactful change. The current 1,373-line monolith is the root cause of the Gemini CLI destructive edits ‚Äî the LLM couldn't reason about the full file and deleted Phase 4 handlers instead of fixing a variable name. Smaller files = better AI compatibility.
